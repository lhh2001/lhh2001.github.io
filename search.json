[{"title":"UE借助Lua5.4的to-be-closed特性打性能标签","path":"/2025/07/07/UE借助Lua5-4的to-be-closed特性打性能标签/","content":"背景UE中打性能标签，一般是借助SCOPED_NAMED_EVENT系列宏或者SCOPE_CYCLE_COUNTER系列宏完成，随后可以在Unreal Insights中进行分析。他们的原理类似。以SCOPED_NAMED_EVENT宏为例，实际上是在需要分析效率的作用域，定义一个FScopedNamedEventStatic类型的结构体。程序运行到这个作用域时，会执行这个结构体的构造函数，调用一次FPlatformMisc::BeginNamedEvent；离开这个作用域的时候，会执行这个结构体的析构函数，调用一次FPlatformMisc::EndNamedEvent。 // 宏定义#define SCOPED_NAMED_EVENT(Name, Color) \\\tFScopedNamedEventStatic ANONYMOUS_VARIABLE(NamedEvent_##Name##_)(Color, NAMED_EVENT_STR(#Name));// FScopedNamedEventStatic定义(省略部分代码)class CORE_API FScopedNamedEventStaticpublic:\tFScopedNamedEventStatic(const struct FColor Color, const TCHAR* Text) FPlatformMisc::BeginNamedEvent(Color, Text); ~FScopedNamedEventStatic() FPlatformMisc::EndNamedEvent();\t;// 使用方法 SCOPED_NAMED_EVENT(DoSomething, FColor::Magenta); // Do something... Lua中，并不存在构造函数与析构函数，所以如果需要分析某个函数性能，只能将BeginNamedEvent和EndNamedEvent两个函数导出至Lua侧，然后在合适的时机去调用： local function Foo() BeginNamedEvent(DoSomething) -- Do something... EndNamedEvent()end 旧方法存在的问题UE中必须保证BeginNamedEvent和EndNamedEvent两个函数成对出现，否则会出现这样的情况，从某个时间点往后的数据都炸掉了，导致这次跑出的utrace文件作废： 在Lua通过显式调用的方式打标签，经常会遇到这种问题，主要可以分成三种情况： 1. 函数提前return遗漏End函数的调用local function Foo() BeginNamedEvent(DoSomething) if Bar() then -- !! return end -- Do something... EndNamedEvent()end 开发的过程中，经常需要在原有的函数里增加一个分支，然后提前return，这种情况下非常容易遗漏End的调用。如果依靠程序员手动维护，保证在每一个return前都调用End函数，既不可靠又增加了维护的成本。这里一个妥协的方法是再套一层函数，但是每次调用Foo会有额外的成本： local function FooInternal() if Bar() then return end -- Do something...endlocal function Foo() BeginNamedEvent(DoSomething) FooInternal() EndNamedEvent()end 2. 函数运行过程中出现了错误local function Foo() BeginNamedEvent(DoSomething) -- Do something... -- Some error happens... EndNamedEvent()end 这也是一个非常常见的情况。Foo函数开始调用了Begin函数，但是运行的过程中出现了某些错误，导致函数后续的逻辑没有执行，End函数没有调用到。一种妥协的方法是使用pcall或者xpcall执行内部的逻辑： local function FooInternal() -- Do something... -- Some error happens...endlocal function Foo() BeginNamedEvent(DoSomething) pcall(FooInternal) EndNamedEvent()end 除了增加了一次函数调用之外，pcall因为要记录一些额外的信息会更耗。 3. 使用协程导致的问题如果函数是使用协程异步执行的，那么它的各个部分不一定是在同一帧执行的，也很容易出现Begin和End不匹配的情况： -- Do something 2 如果在下一帧执行, 就会出现不匹配的情况local function Foo() BeginNamedEvent(DoSomething) -- Do something 1... coroutine.yield() -- Do something 2... EndNamedEvent()end-- 这样处理更保险，但是增加了维护成本local function Foo() BeginNamedEvent(DoSomething1) -- Do something 1... EndNamedEvent() coroutine.yield() BeginNamedEvent(DoSomething2) -- Do something 2... EndNamedEvent()end Lua 5.4 to-be-closed 特性to-be-closed是Lua在5.4版本新增的特性。 简单来说，通过local Var close = xxx的方式，可以将Var变量定义为一个to-be-closed类型的变量。该变量可以当作一个正常的变量使用，但是在离开该变量的作用域后，如果Var是一个table，Lua会调用这个table元表中的__close方法。如果有多个to-be-closed变量同时离开了作用域，会按照变量定义顺序相反的顺序执行__close函数，和C++的行为是类似的。 可以通过指定元表中的__close方法，来实现类似于析构函数的行为，或者更高级的类似RAII的机制。比如下面的程序，会依次打印ABCD，其中__close会在离开ClosedVar变量的作用域之后立即执行。 local ClosedMetatable = __close = function() print(C) endlocal function Foo() print(A) do local ClosedVar close = setmetatable(, ClosedMetatable) print(B) end print(D)endFoo() 借助 to-be-closed 特性保证Begin和End函数的成对调用local ProfileTag = setmetatable(ProfileTag, __close = EndNamedEvent)local function MakeProfileTag(Name)\tif Name then BeginNamedEvent(Name) return ProfileTag\tendendlocal function Foo() local _ close = MakeProfileTag(DoSomething) -- Do something...end 上面的方式可以从语言层面上保证Begin与End成对出现，即使出现了报错也能正确调用EndNamedEvent。MakeProfileTag函数可以放到某个公共的lua文件里，或者定义为全局函数。 使用的过程中，有两个点需要注意： 1 所有to-be-closed变量共用同一个表ProfileTag，可以节省内存，避免每次创建出来一个新的表； 2 为了方便使用，可以使用_命名变量。如果某个作用域的to-be-closed变量和上层的to-be-closed变量重名也不会影响逻辑的正确性，可以放心地都命名成_，不用每次都想个新的名字。 一些补充即使使用了to-be-closed特性，上面提到第三个问题，即协程异步执行的问题，也是没办法避免的。一个比较方便的方法，是将异步执行的函数的不同部分用do-end包裹起来，然后结合to-be-closed特性打标签： local function Foo() do local _ close = MakeProfileTag(DoSomething1) -- Do something 1... end coroutine.yield() do local _ close = MakeProfileTag(DoSomething2) BeginNamedEvent(DoSomething2) endend LuaJIT的作者曾经痛批to-be-closed特性(指路链接)，认为它的设计是个错误，更改了Lua原先简洁的设计，但是收益很小。但是个人觉得在打性能标签这个问题上，to-be-closed特性还是很好用的，也没遇到过什么bug。","tags":["Lua","UnLua","UE","性能分析"],"categories":["技术相关"]},{"title":"Hexo + GitHub Pages 部署个人博客记录","path":"/2025/07/04/Hexo-GitHub-Pages-部署个人博客记录/","content":"各种细节网络上各种资料已经非常详细，主要记录一下遇到的问题，顺便熟悉下发 blog 的流程。 配置Hexo需要先配置一下nodejs的环境，按照Hexo的文档 | Hexo中步骤安装即可，没遇到什么太大的问题。 配置GitHub Pages按照创建 GitHub Pages 站点 - GitHub Docs中的步骤配置即可。 需要注意： 仓库名有严格的要求，即user.github.io，user 为用户名； 如果是个人用户，仓库可见性需要为Public，否则无法正常使用。 部署环境参考一键部署 | Hexo，进行简单的配置后，就可以一键部署发布了，几分钟就可以看到变更。 插入图片使用hexo-asset-img插件辅助。参照README中的步骤，如果Hexo的版本大于7，要安装1.2.0版本的插件： npm install hexo-asset-img@1.2.0 --save 这个插件网络上使用教程比较多，不过建议直接参照github仓库主页下的README操作。 评论区我采用的方案是Stellar主题 + giscus，不同主题的配置方法可能会有一些区别。官方文档上没有给出详细的步骤，这里展开说一下： 安装并使用Stellar主题Stellar：开始您全新的博客之旅 - XAOXUU 参照GitHub Discussions 快速入门 - GitHub Enterprise Cloud Docs中的步骤，开启某个仓库（可以是github.io对应的仓库）的 Discussion 功能，随后开启一个名为 Announcements 的讨论： 在giscus上进行相关配置，仓库名称按照[github用户名]/[仓库名]填写，映射关系选择URL，Discussion 分类填写 Announcements。 滑到下方，会生成一个script标签。因为使用了主题，我们不需要直接使用这个标签，只需要复制其中的信息然后进行配置即可，下一步会介绍配置的方法。 在Hexo的_config.yml文件同级目录创建文件_config.stellar.yml，然后填入下面的配置： comments: service: giscus # giscus # https://giscus.app/zh-CN giscus: src: https://giscus.app/client.js data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: lazy crossorigin: anonymous 将data-repo data-repo-id data-category data-category-id几个属性根据script标签中的信息填写即可。注意这些配置写在_config.yml中是无效的，一定得放在_config.stellar.yml里面。","tags":["杂项"],"categories":["杂项"]}]