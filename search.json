[{"title":"Lua实现类似C#的?.(Null条件运算符)语法","path":"/2025/07/25/Lua实现类似C-的-Null条件运算符-语法/","content":"导言这篇文章围绕Lua访问表中嵌套多层字段判空的问题，介绍了几种常见的方法。随后，介绍了我在Lua中实现?.语法的思路（对这部分不感兴趣可以跳过 实现思路 部分），最后比较了文章中提到的几种方法的性能。 背景Lua中经常会出现这样的代码来访问某些嵌套表的字段： local var = a.b.c.d-- do something with var 但是如果其中某一个表可能为nil，就很容易引发attempt to index a nil value的错误，需要加上判空： local varif a and a.b and a.b.c then var = a.b.c.dend 如果按照上面的代码实现，又会有隐藏的性能问题，a.b.c.d只需要3次表的索引，但是现在的写法需要6次索引，如下图： 第1 2 4次都是重复索引a.b，第3 5都是重复索引b.c。我们可以通过局部变量缓存索引结果，优化掉这部分耗时： local varif a then local b = a.b if b then local c = b.c if c then var = c.d end endend 虽然解决了索引的问题，但是代码变得越来越不优雅了。 还有其他三种流派的方式去规避这个问题，但是也没办法不引入任何额外的开销： 0. 静态分析为了规避Lua表重复索引的性能问题，通过正则匹配等手段，静态分析Lua代码，然后将其替换成更有效率的形式，也是一种方案，但是这里不展开讨论了。一般被替换的代码也是上面或者下面提到的形式。 1. 使用or简化判空local var = (((a or ).b or ).c or ).d 这个方法相对来说简洁一点，但是不够直观，如果对这种写法不太熟悉，可能没法一眼看出来在干什么。而且，每次执行到这里，如果a b c均为空，会创建出来3个空表。 通过共享同一个表empty_table，可以避免创建很多辅助的空表： local empty_table = local var = (((a or empty_table).b or empty_table).c or empty_table).d 已经是一个比较不错的解决方案，但是因为引入了empty_table，也算不上0额外开销。 2. 给nil设置元表-- 空表debug.setmetatable(nil, __index = )-- 空函数debug.setmetatable(nil, __index = function() end )local var = a.b.c.d 正常情况下，setmetatable只能给表类型的变量设置元表。但是借助debug.setmetatable函数，我们可以给nil单独设置一个元表，将__index方法设置成一个空表或者空函数，规避问题。 个人感觉，虽然这个方法可以让使用者不用考虑判空的问题，避免很多冗余的代码，但是有点旁门左道。一方面debug库在某些运行环境下可能没办法正常使用，另一方面这个方法更改了nil变量全局的行为，影响面比较大。 从性能的角度考虑，这个方法会引入一个额外的元表，且每次尝试对nil执行索引都会走一次元表的索引流程。 3. 函数封装行为local function safe_index(table, ...) for _, key in ipairs... do if not table then return nil end table = table[key] end return tableendlocal var = safe_index(a, b, c, d) 使用函数封装也是一种思路。但是从性能角度考虑，会多一层函数的调用，而且函数内部的for循环还有ipairs...这种写法都会引入额外的开销。 恰好在C#中，Null 条件运算符，即?.和?[]这两种运算符，可以非常优雅地访问一个可能为空的变量的成员——即a?.b?.c?.d这种写法。受此启发，同时为了加深对Lua底层机制的理解，尝试在Lua中实现了一下?.运算符。 实现思路Lua语言从编译到执行的过程，可以用下图所示（参考了构建Lua解释器Part7：构建完整的语法分析器(上)）： 如果要实现?.运算符，需要在两个层面上进行扩展： 1 - 词法层面，按照Lua词法分析的设计，增加一种新的token（?.运算符）即可。 2 - 语法语义层面，Lua虚拟机存在OP_GETFIELD指令。我的思路比较简单，仿照OP_GETFIELD指令，新增一种新的指令OP_SAFEGETFIELD，该指令的作用也是获取表中的字段，只不过当表为nil时，会返回nil而不是抛出错误。语法语义分析时，根据?.运算符生成对应的指令即可。 Manistein大佬的博客6 7 8章节深入浅出地介绍了Lua的词法分析与语法分析过程，个人非常喜欢这个系列，如果对Lua有兴趣可以阅读一下。 下面基于Lua 5.5.0版本的实现，介绍一下具体的细节。 1. 新增token词法分析，是将代码字符串转换为token序列的过程，而token是构成源代码的最小单位。比如，print(Hello, World!)就会被分割成： TK_NAME, print(TK_STRING, Hello, World!) Lua中执行这部分逻辑的代码位于llex.h和llex.c中。Lua中使用的token被定义在了RESERVED枚举当中，我们只需要在末尾添加一个新的token，用来表示?.这个运算符即可： // llex.h/** WARNING: if you change the order of this enumeration,* grep ORDER RESERVED*/enum RESERVED /* terminal symbols denoted by reserved words */ TK_AND = FIRST_RESERVED, TK_BREAK, TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION, TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT, TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE, /* other terminal symbols */ TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_SHL, TK_SHR, TK_DBCOLON, TK_EOS, TK_FLT, TK_INT, TK_NAME, TK_STRING, TK_NILCONDINDEX // 新增TK_NILCONDINDEX; TK_NILCONDINDEX对应C#中的null条件运算符，是nil condition index的缩写。 仔细观察RESERVED枚举，会发现其实并没有涵盖所有的token，这是因为按照Lua中的定义，单字符token的枚举值和其ASCII编码值相同，因此所有单字符token没有被单独列在枚举中。 TK_AND作为RESERVED枚举的第一个值，从FIRST_RESERVED开始，从FIRST_RESERVED的定义中，可以看出Lua设计的意图： /*** Single-char tokens (terminal symbols) are represented by their own** numeric code. Other tokens start at the following value.*/#define FIRST_RESERVED\t(UCHAR_MAX + 1) 添加了枚举后，还需要在luaX_tokens数组末尾添加一个新的元素，告诉lua这种token的名称是什么，便于lua生成一些调试报错信息。 // llex.c/* ORDER RESERVED */static const char *const luaX_tokens [] = and, break, do, else, elseif, end, false, for, function, goto, if, in, local, nil, not, or, repeat, return, then, true, until, while, //, .., ..., ==, =, =, ~=, , , ::, eof, number, integer, name, string, ?. // 新增?.; lua真正执行词法分析的逻辑在llex函数中，通过一个循环逐个读入字符，然后在switch中分类处理。我们增加一个switch - case，在读到?字符判断下一个字符是不是.；如果是，就认为读到了一个TK_NILCONDINDEX： // llex.cstatic int llex (LexState *ls, SemInfo *seminfo) luaZ_resetbuffer(ls-buff); for (;;) switch (ls-current) case : case \\r: /* line breaks */ inclinenumber(ls); break; case : case \\f: case \\t: case \\v: /* spaces */ next(ls); break; ... // 这部分是新增的case // ++ case ?: next(ls); if (check_next1(ls, .)) return TK_NILCONDINDEX; /* ?. */ else lexerror(ls, invalid operator ?, 0); break; // -- ... 2. 新增一种新的虚拟机指令Lua中，对表进行索引操作的虚拟机指令一般是OP_GETFIELD。我们仿照这个指令，新增一种新的指令OP_SAFEGETFIELD，表示安全地获取表中的字段。这个指令在表为空时，会直接返回nil而不是抛出错误。 Lua中，虚拟机指令即opcode，定义在lopcodes.h中。首先，扩展一下枚举： // lopcodes.htypedef enum /*---------------------------------------------------------------------- name args\tdescription------------------------------------------------------------------------*/OP_MOVE,/*\tA B\tR[A] := R[B] */OP_LOADI,/*\tA sBx\tR[A] := sBx */OP_LOADF,/*\tA sBx\tR[A] := (lua_Number)sBx */...OP_GETFIELD,/*\tA B C\tR[A] := R[B][K[C]:shortstring] */// 这一条是新增的// ++OP_SAFEGETFIELD,/*\tA B C\tR[A] := R[B][K[C]:shortstring], R[A] := nil if R[B] not a table */// --... OpCode; OP_GETFIELD指令含义如下：寄存器B中存放一张表，我们需要从这个表中，根据寄存器C字符串的值，取出某个字段，然后将结果存放在寄存器A中。 新增枚举后，需要扩展lopcodes.c的luaP_opmodes数组，定义这种指令的mode。新指令的构成还有用法和OP_GETFIELD是完全相同的，复用其值即可： LUAI_DDEF const lu_byte luaP_opmodes[NUM_OPCODES] = /* MM OT IT T A mode opcode */ ... ,opmode(0, 0, 0, 0, 1, iABC) /* OP_GETFIELD */ // ++ ,opmode(0, 0, 0, 0, 1, iABC) /* OP_SAFEGETFIELD */ // 这一行是新增的 // -- ...; Lua虚拟机执行指令的核心函数为luaV_execute，这个函数会逐个取出opcode，根据不同的类型做出不同的操作。 在索引前先判断一下寄存器B中的值是不是nil，其余部分仿照OP_GETFIELD的处理方式，就可以实现OP_SAFEGETFIELD指令： //lvm.c// 剔除了无关理解的代码void luaV_execute (lua_State *L, CallInfo *ci) ... /* main loop of interpreter */ for (;;) ... vmdispatch (GET_OPCODE(i)) ... vmcase(OP_GETFIELD) StkId ra = RA(i); TValue *rb = vRB(i); TValue *rc = KC(i); TString *key = tsvalue(rc); /* key must be a short string */ lu_byte tag; luaV_fastget(rb, key, s2v(ra), luaH_getshortstr, tag); if (tagisempty(tag)) Protect(luaV_finishget(L, rb, rc, ra, tag)); vmbreak; // 这个case是新增的 // ++ vmcase(OP_SAFEGETFIELD) StkId ra = RA(i); TValue *rb = vRB(i); TValue *rc = KC(i); TString *key = tsvalue(rc); /* key must be a short string */ lu_byte tag; if (ttisnil(rb)) // 如果寄存器B的值为nil, 直接将寄存器A的值设置为nil setnilvalue(s2v(ra)); else // 否则, 和OP_GETFIELD后续的处理流程相同 luaV_fastget(rb, key, s2v(ra), luaH_getshortstr, tag); if (tagisempty(tag)) Protect(luaV_finishget(L, rb, rc, ra, tag)); vmbreak; // -- ... 3. 语法语义分析的处理现在，我们有了token，也有了对应的指令，接下来需要让Lua可以根据token去生成对应的指令。这部分的工作由Lua的语法语义分析模块完成。 Lua的语法语义分析是放在一起处理的，逻辑在lparser.h和lparser.c中。官方文档中给出了Lua 5.4的BNF范式，但是看lparser.c中具体函数的注释会更详细一点，函数名一般就是范式中某个非终结符的名字。 对于访问表中的某个字段来说，需要关注下面几种范式： suffixedexp - primaryexp . NAME | [ exp ] | : NAME funcargs | funcargs funcname - NAME fieldsel [: NAME]fieldsel - [. | :] NAME 观察suffixedexp函数的实现，虽然范式中没有体现，但是对于通过.访问表字段的语法，也是通过fieldsel来实现的。 // lparser.cstatic void suffixedexp (LexState *ls, expdesc *v) /* suffixedexp - primaryexp . NAME | [ exp ] | : NAME funcargs | funcargs */ FuncState *fs = ls-fs; primaryexp(ls, v); for (;;) switch (ls-t.token) case .: /* fieldsel */ fieldsel(ls, v); break; case [: /* [ exp ] */ expdesc key; luaK_exp2anyregup(fs, v); yindex(ls, key); luaK_indexed(fs, v, key); break; case :: /* : NAME funcargs */ expdesc key; luaX_next(ls); codename(ls, key); luaK_self(fs, v, key); funcargs(ls, v); break; case (: case TK_STRING: case /**/: /* funcargs */ luaK_exp2nextreg(fs, v); funcargs(ls, v); break; default: return; 因此，将fieldsel增加一个参数，用来区分当前的索引是普通的索引，还是?.对应的需要判空的索引： // lparser.c// ctn是新增的参数, 表示是否需要检查表为空(check table nil)static void fieldsel (LexState *ls, expdesc *v, int ctn) /* fieldsel - [. | :] NAME */ FuncState *fs = ls-fs; expdesc key; luaK_exp2anyregup(fs, v); luaX_next(ls); /* skip the dot or colon */ codename(ls, key); luaK_indexed(fs, v, key); // 这里将ctn的值存在结构体v中 // ++ v-ctn = ctn; // -- 这里遇到一个新的结构体expdesc，它的作用是记录当前表达式的一些信息。Lua编译（解释）代码是一边分析token一边生成指令的，对于一个表达式来说，Lua会先将分析过程中得到的信息记录在expdesc结构体中，等到必要的时候再消耗(discharge)结构体中保存的信息，生成对应的指令。之后，重复 记录信息 - 生成指令 的过程，直到将整个表达式转换成虚拟机指令。 fieldsel中，luaK_exp2anyregup函数就是完成 消耗信息生成指令 这个工作的。也就是说，每次进入fieldsel函数，都会先尝试消耗掉之前的信息，再去记录新的信息。举个例子，对于表达式a.b.c.d，分析到b.c的时候，会消耗之前存储的信息，将a.b生成一条OP_GETFIELD指令。 expdesc结构体本身并没有ctn这个变量，因此也需要扩充一下： // lparser.htypedef struct expdesc expkind k; union lua_Integer ival; /* for VKINT */ lua_Number nval; /* for VKFLT */ TString *strval; /* for VKSTR */ int info; /* for generic use */ struct /* for indexed variables */ short idx; /* index (R or long K) */ lu_byte t; /* table (register or upvalue) */ ind; struct /* for local variables */ lu_byte ridx; /* register holding the variable */ unsigned short vidx; /* compiler index (in actvar.arr) */ var; u; int t; /* patch list of exit when true */ int f; /* patch list of exit when false */ // ++ int ctn; /* whether to check table is nil */ // 新增 // -- expdesc; 因为结构体中新增了变量，需要在合适的位置初始化： // lcode.c/*** Create expression t[k]. t must have its final result already in a** register or upvalue. Upvalues can only be indexed by literal strings.** Keys can be literal strings in the constant table or arbitrary** values in registers.*/void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) if (k-k == VKSTR) str2K(fs, k); lua_assert(!hasjumps(t) (t-k == VLOCAL || t-k == VNONRELOC || t-k == VUPVAL)); if (t-k == VUPVAL !isKstr(fs, k)) /* upvalue indexed by non Kstr? */ luaK_exp2anyreg(fs, t); /* put it in a register */ if (t-k == VUPVAL) lu_byte temp = cast_byte(t-u.info); /* upvalue index */ lua_assert(isKstr(fs, k)); t-u.ind.t = temp; /* (cant do a direct assignment; values overlap) */ t-u.ind.idx = cast(short, k-u.info); /* literal short string */ t-k = VINDEXUP; else /* register index of the table */ t-u.ind.t = cast_byte((t-k == VLOCAL) ? t-u.var.ridx: t-u.info); if (isKstr(fs, k)) t-u.ind.idx = cast(short, k-u.info); /* literal short string */ t-k = VINDEXSTR; // 这里给ctn一个初始值 // ++ t-ctn = 0; // -- else if (isCint(k)) /* int. constant in proper range? */ t-u.ind.idx = cast(short, k-u.ival); t-k = VINDEXI; else t-u.ind.idx = cast(short, luaK_exp2anyreg(fs, k)); /* register */ t-k = VINDEXED; 接下来，简单修改suffixedexp和funcname两条范式的逻辑，根据情况传入正确的ctn值即可： // lparser.cstatic void suffixedexp (LexState *ls, expdesc *v) /* suffixedexp - primaryexp . NAME | [ exp ] | : NAME funcargs | funcargs */ FuncState *fs = ls-fs; primaryexp(ls, v); for (;;) switch (ls-t.token) case .: /* fieldsel */ // 原有的逻辑, 不需要判空, 传0 fieldsel(ls, v, 0); break; // 新增一个case // ++ case TK_NILCONDINDEX: // 需要判空传1 fieldsel(ls, v, 1); break; // -- ... static int funcname (LexState *ls, expdesc *v) /* funcname - NAME fieldsel [: NAME] */ int ismethod = 0; singlevar(ls, v); while (ls-t.token == .) fieldsel(ls, v, 0); // 不需要判空传0 if (ls-t.token == :) ismethod = 1; fieldsel(ls, v, 0); // 不需要判空传0 return ismethod; 最后，在生成opcode的时候，根据ctn的值选择合适的指令： // lcode.c/*** Ensure that expression e is not a variable (nor a const).** (Expression still may have jump lists.)*/void luaK_dischargevars (FuncState *fs, expdesc *e) switch (e-k) ... case VINDEXSTR: freereg(fs, e-u.ind.t); // 这里如果ctn为1, 选择OP_SAFEGETFIELD指令 e-u.info = luaK_codeABC(fs, e-ctn ? OP_SAFEGETFIELD : OP_GETFIELD, 0, e-u.ind.t, e-u.ind.idx); e-k = VRELOC; break; ... 4. 其他一些小细节以上所有的处理，并不是在OP_GETFIELD指令的基础上进行扩展。如果直接在OP_GETFIELD基础上扩充，可能导致所有OP_GETFIELD指令因为增加了额外的逻辑，耗时略微增加，所以我选择的方法是添加一个新的指令。 采用这个方法的坏处就是新的指令没办法直接复用OP_GETFIELD的处理流程，因此代码中原先用到OP_GETFIELD的地方，都需要扩展一下，避免遗漏。不过也不算很繁琐： // ldebug.c/*** Extend basicgetobjname to handle table accesses*/static const char *getobjname (const Proto *p, int lastpc, int reg, const char **name) ... switch (op) ... case OP_GETI: *name = integer index; return field; // 加上case OP_SAFEGETFIELD case OP_GETFIELD: case OP_SAFEGETFIELD: int k = GETARG_C(i); /* key index */ kname(p, k, name); return isEnv(p, lastpc, i, 0); ... return NULL; /* could not find reasonable name *//*** Try to find a name for a function based on the code that called it.** (Only works when function was called by a Lua function.)** Returns what the name is (e.g., for iterator, method,** metamethod) and sets *name to point to the name.*/static const char *funcnamefromcode (lua_State *L, const Proto *p, int pc, const char **name) TMS tm = (TMS)0; /* (initial value avoids warnings) */ Instruction i = p-code[pc]; /* calling instruction */ switch (GET_OPCODE(i)) ... // 加上case OP_SAFEGETFIELD /* other instructions can do calls through metamethods */ case OP_SELF: case OP_GETTABUP: case OP_GETTABLE: case OP_GETI: case OP_GETFIELD: case OP_SAFEGETFIELD: tm = TM_INDEX; break; ... *name = getshrstr(G(L)-tmname[tm]) + 2; return metamethod; // lvm.c/*** finish execution of an opcode interrupted by a yield*/void luaV_finishOp (lua_State *L) CallInfo *ci = L-ci; StkId base = ci-func.p + 1; Instruction inst = *(ci-u.l.savedpc - 1); /* interrupted instruction */ OpCode op = GET_OPCODE(inst); switch (op) /* finish its execution */ ... // 加上case OP_SAFEGETFIELD case OP_UNM: case OP_BNOT: case OP_LEN: case OP_GETTABUP: case OP_GETTABLE: case OP_GETI: case OP_GETFIELD: case OP_SAFEGETFIELD: case OP_SELF: setobjs2s(L, base + GETARG_A(inst), --L-top.p); break; ... 另外，在check_conflict函数里面，expdesc中的ctn变量在发生冲突时需要重置： // lparser.c/*** check whether, in an assignment to an upvalue/local variable, the** upvalue/local variable is begin used in a previous assignment to a** table. If so, save original upvalue/local value in a safe place and** use this safe copy in the previous assignment.*/static void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) ... for (; lh; lh = lh-prev) /* check all previous assignments */ if (vkisindexed(lh-v.k)) /* assignment to table field? */ if (lh-v.k == VINDEXUP) /* is table an upvalue? */ if (v-k == VUPVAL lh-v.u.ind.t == v-u.info) conflict = 1; /* table is the upvalue being assigned now */ lh-v.k = VINDEXSTR; lh-v.u.ind.t = extra; /* assignment will use safe copy */ // 冲突产生时重置ctn的值 // ++ lh-v.ctn = 0; // -- ... 性能对比将上面提到的几种方法的耗时进行了对比。首先，将a b c d的值分成了五种情况： -- a.b = b; b.c = c; c.d = d;a, b, c, d = nil, nil, nil, nil -- 情况1a, b, c, d = , nil, nil, nil -- 情况2a, b, c, d = , , nil, nil -- 情况3a, b, c, d = , , , nil -- 情况4a, b, c, d = , , , -- 情况5 然后，分别将每种方法访问a.b.c.d做5000000次循环，统计耗时（毫秒），结果如下： 情况1 情况2 情况3 情况4 情况5 if - else（简单粗暴版） 42 73 106 153 148 if - else （局部变量缓存索引结果） 54 66 93 100 93 使用or简化判空 1102 744 407 103 94 使用or简化判空（共享同一张空表） 214 212 126 104 96 函数封装行为 1539 1691 1858 2157 2134 自定义的?.操作符 40 59 67 76 63 给nil设置元表（__index = ） 231 140 108 75 62 给nil设置元表（__index = function() end） 419 328 189 75 62 简单分析一下： 最耗时的两个方法：函数封装行为 和 使用or判空。多一层函数调用和创建空表的开销都是比较大的； 使用or判空的方法，在通过共享空表优化后，耗时可以显著地降低； if - else使用局部变量缓存的优化效果不是很明显，在某些情况下甚至还不如暴力的写法，可能是因为测试用例中表的规模太小，索引操作的耗时没有成为瓶颈； 两种元表的方法，比function() end要高效一些，因为后一种方法会多一层函数调用； 使用or简化判空 和 给nil设置__index = 元表 的耗时差不多，因为原理是相似的； ?.操作符性能大部分情况下是最优的，因为它通过直接修改底层实现，可以用最少的指令数完成操作。 本文中使用的Lua和测试代码：lhh2001luatoy at githubnilcondindex 参考资料成员访问和 Null 条件运算符和表达式： - C# reference | Microsoft Learn lua table - Lua equivalent for null conditional operator? - Stack Overflow if statement - Lua : attempt to index a nil value; avoiding errors in conditionals - Stack Overflow Lua 5.4 Reference Manual 构建Lua解释器Part6：词法分析器设计与实现 构建Lua解释器Part7：构建完整的语法分析器(上) 构建Lua解释器Part8：构建完整的语法分析器(下)","tags":["Lua"],"categories":["技术相关"]},{"title":"UE借助Lua5.4的to-be-closed特性打性能标签","path":"/2025/07/07/UE借助Lua5-4的to-be-closed特性打性能标签/","content":"背景UE中打性能标签，一般是借助SCOPED_NAMED_EVENT系列宏或者SCOPE_CYCLE_COUNTER系列宏完成，随后可以在Unreal Insights中进行分析。他们的原理类似。以SCOPED_NAMED_EVENT宏为例，实际上是在需要分析效率的作用域，定义一个FScopedNamedEventStatic类型的结构体。程序运行到这个作用域时，会执行这个结构体的构造函数，调用一次FPlatformMisc::BeginNamedEvent；离开这个作用域的时候，会执行这个结构体的析构函数，调用一次FPlatformMisc::EndNamedEvent。 // 宏定义#define SCOPED_NAMED_EVENT(Name, Color) \\\tFScopedNamedEventStatic ANONYMOUS_VARIABLE(NamedEvent_##Name##_)(Color, NAMED_EVENT_STR(#Name));// FScopedNamedEventStatic定义(省略部分代码)class CORE_API FScopedNamedEventStaticpublic:\tFScopedNamedEventStatic(const struct FColor Color, const TCHAR* Text) FPlatformMisc::BeginNamedEvent(Color, Text); ~FScopedNamedEventStatic() FPlatformMisc::EndNamedEvent();\t;// 使用方法 SCOPED_NAMED_EVENT(DoSomething, FColor::Magenta); // Do something... Lua中，并不存在构造函数与析构函数，所以如果需要分析某个函数性能，只能将BeginNamedEvent和EndNamedEvent两个函数导出至Lua侧，然后在合适的时机去调用： local function Foo() BeginNamedEvent(DoSomething) -- Do something... EndNamedEvent()end 旧方法存在的问题UE中必须保证BeginNamedEvent和EndNamedEvent两个函数成对出现，否则会出现这样的情况，从某个时间点往后的数据都炸掉了，导致这次跑出的utrace文件作废： 在Lua通过显式调用的方式打标签，经常会遇到这种问题，主要可以分成三种情况： 1. 函数提前return遗漏End函数的调用local function Foo() BeginNamedEvent(DoSomething) if Bar() then -- !! return end -- Do something... EndNamedEvent()end 开发的过程中，经常需要在原有的函数里增加一个分支，然后提前return，这种情况下非常容易遗漏End的调用。如果依靠程序员手动维护，保证在每一个return前都调用End函数，既不可靠又增加了维护的成本。这里一个妥协的方法是再套一层函数，但是每次调用Foo会有额外的成本： local function FooInternal() if Bar() then return end -- Do something...endlocal function Foo() BeginNamedEvent(DoSomething) FooInternal() EndNamedEvent()end 2. 函数运行过程中出现了错误local function Foo() BeginNamedEvent(DoSomething) -- Do something... -- Some error happens... EndNamedEvent()end 这也是一个非常常见的情况。Foo函数开始调用了Begin函数，但是运行的过程中出现了某些错误，导致函数后续的逻辑没有执行，End函数没有调用到。一种妥协的方法是使用pcall或者xpcall执行内部的逻辑： local function FooInternal() -- Do something... -- Some error happens...endlocal function Foo() BeginNamedEvent(DoSomething) pcall(FooInternal) EndNamedEvent()end 除了增加了一次函数调用之外，pcall因为要记录一些额外的信息会更耗。 3. 使用协程导致的问题如果函数是使用协程异步执行的，那么它的各个部分不一定是在同一帧执行的，也很容易出现Begin和End不匹配的情况： -- Do something 2 如果在下一帧执行, 就会出现不匹配的情况local function Foo() BeginNamedEvent(DoSomething) -- Do something 1... coroutine.yield() -- Do something 2... EndNamedEvent()end-- 这样处理更保险，但是增加了维护成本local function Foo() BeginNamedEvent(DoSomething1) -- Do something 1... EndNamedEvent() coroutine.yield() BeginNamedEvent(DoSomething2) -- Do something 2... EndNamedEvent()end Lua 5.4 to-be-closed 特性to-be-closed是Lua在5.4版本新增的特性。 简单来说，通过local Var close = xxx的方式，可以将Var变量定义为一个to-be-closed类型的变量。该变量可以当作一个正常的变量使用，但是在离开该变量的作用域后，如果Var是一个table，Lua会调用这个table元表中的__close方法。如果有多个to-be-closed变量同时离开了作用域，会按照变量定义顺序相反的顺序执行__close函数，和C++的行为是类似的。 可以通过指定元表中的__close方法，来实现类似于析构函数的行为，或者更高级的类似RAII的机制。比如下面的程序，会依次打印ABCD，其中__close会在离开ClosedVar变量的作用域之后立即执行。 local ClosedMetatable = __close = function() print(C) endlocal function Foo() print(A) do local ClosedVar close = setmetatable(, ClosedMetatable) print(B) end print(D)endFoo() 借助 to-be-closed 特性保证Begin和End函数的成对调用local ProfileTag = setmetatable(ProfileTag, __close = EndNamedEvent)local function MakeProfileTag(Name)\tif Name then BeginNamedEvent(Name) return ProfileTag\tendendlocal function Foo() local _ close = MakeProfileTag(DoSomething) -- Do something...end 上面的方式可以从语言层面上保证Begin与End成对出现，即使出现了报错也能正确调用EndNamedEvent。MakeProfileTag函数可以放到某个公共的lua文件里，或者定义为全局函数。 使用的过程中，有两个点需要注意： 1 所有to-be-closed变量共用同一个表ProfileTag，可以节省内存，避免每次创建出来一个新的表； 2 为了方便使用，可以使用_命名变量。如果某个作用域的to-be-closed变量和上层的to-be-closed变量重名也不会影响逻辑的正确性，可以放心地都命名成_，不用每次都想个新的名字。 一些补充即使使用了to-be-closed特性，上面提到第三个问题，即协程异步执行的问题，也是没办法避免的。一个比较方便的方法，是将异步执行的函数的不同部分用do-end包裹起来，然后结合to-be-closed特性打标签： local function Foo() do local _ close = MakeProfileTag(DoSomething1) -- Do something 1... end coroutine.yield() do local _ close = MakeProfileTag(DoSomething2) BeginNamedEvent(DoSomething2) endend LuaJIT的作者曾经痛批to-be-closed特性(指路链接)，认为它的设计是个错误，更改了Lua原先简洁的设计，但是收益很小。但是个人觉得在打性能标签这个问题上，to-be-closed特性还是很好用的，也没遇到过什么bug。","tags":["Lua","UnLua","UE","性能分析"],"categories":["技术相关"]},{"title":"Hexo + GitHub Pages 部署个人博客记录","path":"/2025/07/04/Hexo-GitHub-Pages-部署个人博客记录/","content":"各种细节网络上各种资料已经非常详细，主要记录一下遇到的问题，顺便熟悉下发 blog 的流程。 配置Hexo需要先配置一下nodejs的环境，按照Hexo的文档 | Hexo中步骤安装即可，没遇到什么太大的问题。 配置GitHub Pages按照创建 GitHub Pages 站点 - GitHub Docs中的步骤配置即可。 需要注意： 仓库名有严格的要求，即user.github.io，user 为用户名； 如果是个人用户，仓库可见性需要为Public，否则无法正常使用。 部署环境参考一键部署 | Hexo，进行简单的配置后，就可以一键部署发布了，几分钟就可以看到变更。 插入图片使用hexo-asset-img插件辅助。参照README中的步骤，如果Hexo的版本大于7，要安装1.2.0版本的插件： npm install hexo-asset-img@1.2.0 --save 这个插件网络上使用教程比较多，不过建议直接参照github仓库主页下的README操作。 评论区我采用的方案是Stellar主题 + giscus，不同主题的配置方法可能会有一些区别。官方文档上没有给出详细的步骤，这里展开说一下： 安装并使用Stellar主题Stellar：开始您全新的博客之旅 - XAOXUU 参照GitHub Discussions 快速入门 - GitHub Enterprise Cloud Docs中的步骤，开启某个仓库（可以是github.io对应的仓库）的 Discussion 功能，随后开启一个名为 Announcements 的讨论： 在giscus上进行相关配置，仓库名称按照[github用户名]/[仓库名]填写，映射关系选择URL，Discussion 分类填写 Announcements。 滑到下方，会生成一个script标签。因为使用了主题，我们不需要直接使用这个标签，只需要复制其中的信息然后进行配置即可，下一步会介绍配置的方法。 在Hexo的_config.yml文件同级目录创建文件_config.stellar.yml，然后填入下面的配置： comments: service: giscus # giscus # https://giscus.app/zh-CN giscus: src: https://giscus.app/client.js data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: lazy crossorigin: anonymous 将data-repo data-repo-id data-category data-category-id几个属性根据script标签中的信息填写即可。注意这些配置写在_config.yml中是无效的，一定得放在_config.stellar.yml里面。","tags":["杂项"],"categories":["杂项"]}]